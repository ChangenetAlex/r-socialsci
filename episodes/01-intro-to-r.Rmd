---
title: Introduction to R
teaching: 50
exercises: 30
source: Rmd
---

```{r setup, include=FALSE}
source("data/download_data.R")
```

:::: instructor

- The main goal is to introduce users to the various objects in R, from atomic types
  to creating your own objects.

::::::::::::

::::::::::::::::::::::::::::::::::::::: objectives

- Define: object, assign, call, function, arguments, options.
- Assign values to names in R.
- Learn how to name objects.
- Use comments to inform script.
- Solve simple arithmetic operations in R.
- Call functions and use arguments to change their default options.
- Inspect the content of vectors and manipulate their content.
- Subset values from vectors.
- Analyze vectors with missing data.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- What data types are available in R?
- What is an object?
- How can objects of different data types be assigned to names?
- What arithmetic and logical operators can be used?
- How can subsets be extracted from vectors?
- How does R treat missing values?
- How can we deal with missing values in R?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Creating objects in R

```{r, purl=FALSE}
3 + 5
12 / 7
```

Everything that exists in `R` is an objects: from simple numerical values, to strings, to more complex objects like vectors, matrices, and lists.

However, to do useful and interesting things, we need to name objects. To do so, we need to give a *name* followed by the assignment operator `<-`, and the *object* we want to be named:

```{r, purl=FALSE}
area_hectares <- 1.0
```

`<-` is the assignment operator. It assigns values (objects) on the right to names on
the left.

> üí° **Instructor note:** Gives more examples: `x <- 3`

Goes into. Can also use "=" but not every context. Best <- (Shortcut)

* Can name: `x`, `current_temperature`, or `subject_id`. You want your object names to be explicit and not too long.  
* They cannot start with a number (`2x` is not valid, but `x2` is). 
* Case sensitive (e.g., `age` `Age`). 
* Cannot use `if`, `else`, `for`. 
* It's also best to avoid dots (`.`) within an object name as in `my.dataset`. dots
have a special meaning in R (for methods) and other programming languages, it's
best to avoid them.  
* snake\_case, lowercaseletters and underscores. 
* Consistent coding style makes your code clearer to read for your future self and your
collaborators. 

:::::::::::::::::::::::::::::::::::::::::  callout

:::: instructor
### Note on `<-` vs `<` with negative numbers

- Logical test: `x < -5`   (note the space between "<" and the "-" negative)  
- Assignment:   `x <- 5`

::::::::::::

## Objects vs. variables

Depending on the context, `name (of an object)` and `variable` can
have drastically different meanings. However, in this lesson, the two words
are used synonymously.

::::::::::::::::::::::::::::::::::::::::::::::::::

When assigning a value to a name, R does not print anything. You
can force R to print the value by using parentheses or by typing
the object name:

```{r, purl=FALSE}
area_hectares <- 1.0    # doesn't print anything
(area_hectares <- 1.0)  # putting parenthesis around the call prints the value of `area_hectares`
area_hectares         # and so does typing the name of the object
```

`area_hectares` in memory convert this area into acres. 

```{r, purl=FALSE}
2.47 * area_hectares
```

We can also change the value assigned by assigning a new one:

```{r, purl=FALSE}
area_hectares <- 2.5
2.47 * area_hectares
```

This means that assigning a value to one name does not change the values of
other names, even if they were defined using them.
For example, let's name the plot's area in acres
`area_acres`:

```{r, purl=FALSE}
area_acres <- 2.47 * area_hectares
```

and then change (reassign) `area_hectares` to 50.

```{r, purl=FALSE}
area_hectares <- 50
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

What do you think is the current value of `area_acres`? 123.5 or
6\.175?

:::::::::::::::  solution

## Solution

The value of `area_acres` is still 6.175 because you have not
re-run the line `area_acres <- 2.47 * area_hectares` since
changing the value of `area_hectares`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Comments

Comments helps explain reasoning and repro.
`#` character.
- Good object name is better than comment and self sufficient. 

```{r}
area_hectares <- 1.0			# land area in hectares
area_acres <- area_hectares * 2.47	# convert to acres
area_acres				# print land area in acres.
```

- Comment or uncomment a paragraph: 
<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>.

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Create two variables `r_length` and `r_width` and assign them values. It should be noted that,
because `length` is a built-in R function, R Studio might add "()" after you type `length` and
if you leave the parentheses you will get unexpected results.
This is why you might see other programmers abbreviate common words.
Create a third variable `r_area` and give it a value based on the current values of `r_length`
and `r_width`.
Show that changing the values of either `r_length` and `r_width` does not affect the value of
`r_area`.

:::::::::::::::  solution

## Solution

```{r}
r_length <- 2.5
r_width <- 3.2
r_area <- r_length * r_width
r_area
# change the values of r_length and r_width
r_length <- 7.0
r_width <- 6.5
# the value of r_area isn't changed
r_area
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Functions and their arguments

- Objects OK
- Functions are scripts automating (more complicated) sets of commands.
- Predefined, or importing R *packages* (more on that later). 
- Function inputs is/are *arguments*. 
- Functions often (but not always) return a *value* when ran/call

> üí° **Instructor note:** : Show and discuss `sqrt()` example input output requirement

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

> üí° **Instructor note:** : Explain what it does (calc + assign). One argument only.

* Not always numerical, not always single thing. See later.
* Arguments can be anything, not only numbers or filenames.
* Argumentdiffers per function and looked up in the documentation (see below).
* Specified by user or *default* value: *options*. Alter behavior.

> üí° **Instructor note:** Example multiple argument `round()`.

```{r, results="show", purl=FALSE}
round(3.14159)
```

One arg: nearest whole number. If we want more digits ... Need more info: 

```{r, results="show", purl=FALSE}
args(round)
```

```{r, eval=FALSE, purl=FALSE}
?round
```

We see that if we want a different number of digits, we can
type `digits=2` or however many we want.

```{r, results="show", purl=FALSE}
round(3.14159, digits = 2)
```

If you provide the arguments in the exact same order as they are defined you
don't have to name them:

```{r, results="show", purl=FALSE}
round(3.14159, 2)
```

And if you do name the arguments, you can switch their order:

```{r, results="show", purl=FALSE}
round(digits = 2, x = 3.14159)
```

- good practice repro: non-optional first and specify the names optional arguments. 


:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Type in `?round` at the console and then look at the output in the Help pane.
What other functions exist that are similar to `round`?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Vectors and data types

```{r, echo=FALSE, purl=TRUE}
### Vectors and data types
```

Vector = most common and basic data type in R.
Composed of series of values (numbers or characters).
We can assign a series of values to a vector using the `c()` function. 
Example: create a vector of the number of household
members for the households we've interviewed and assign
it to `hh_members`:

```{r, purl=FALSE}
hh_members <- c(3, 7, 10, 6)
hh_members
```

A vector can also contain characters. 
Interview respondents' walls (`respondent_wall_type`):

```{r, purl=FALSE}
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type
```

Quotes essential here. Objects VS names. Error message. 

```{r, purl=FALSE}
respondent_wall_type <- c(muddaub, "burntbricks", "sunbricks")
```


- Function to inspect the content of a
`length()`

```{r, purl=FALSE}
length(hh_members)
length(respondent_wall_type)
```

- All elements are the same type of data.
`typeof()`: 

```{r, purl=FALSE}
typeof(hh_members)
typeof(respondent_wall_type)
```

`str()` provides an overview of the structure of an object and its
elements. Useful.

```{r, purl=FALSE}
str(hh_members)
str(respondent_wall_type)
```

You can use the `c()` function to add other elements to your vector:

```{r, purl=FALSE}
possessions <- c("bicycle", "radio", "television")
possessions <- c(possessions, "mobile_phone") # add to the end of the vector
possessions <- c("car", possessions) # add to the beginning of the vector
possessions
```

> üí° **Instructor note:** Explain what each line does`.

- We can do this over and over again to assemble a dataset for example.
As we program, this may be useful to add results that we are collecting or
calculating.

**atomic vector** is the simplest R **data type** and is a linear vector of a single type. 
6 main **atomic vector** that R uses: 

- `"character"`
- `"numeric"` (or `"double"`). These are the basic building blocks that
all R objects are built from. The other 4 **atomic vector** types are:
- `"logical"` for `TRUE` and `FALSE` (the boolean data type)
- `"integer"` for integer numbers (e.g., `2L`, the `L` indicates to R that it's an integer)
- `"complex"` (e.g., `1 + 4i`)
- `"raw"` for bitstreams that we won't discuss further

Vectors are one of the many **data structures** that R uses. Other important
ones are lists (`list`), matrices (`matrix`), data frames (`data.frame`),
factors (`factor`) and arrays (`array`).

> üí° **Instructor note:** Sticky notes once third question done (4 optional)`.

:::::::::::::::::::::::::::::::::::::::  challenge


## Exercise

We've seen that atomic vectors can be of type character, numeric (or double),
integer, and logical. But what happens if we try to mix these types in a
single vector?

:::::::::::::::  solution

## Solution

R implicitly converts them to all be the same type.

:::::::::::::::::::::::::

What will happen in each of these examples? (hint: use `class()`
to check the data type of your objects):

```{r, results="hide"}
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
```

Why do you think it happens?

:::::::::::::::  solution

## Solution

Vectors can be of only one data type. R tries to
convert (coerce) the content of this vector to find a "common
denominator" that doesn't lose any information.

:::::::::::::::::::::::::

How many values in `combined_logical` are `"TRUE"` (as a character) in the
following example:

```{r, results="hide"}
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
combined_logical <- c(num_logical, char_logical)
```

:::::::::::::::  solution

## Solution

Only one. There is no memory of past data types, and the coercion
happens the
first time the vector is evaluated. Therefore, the `TRUE` in
`num_logical`
gets converted into a `1` before it gets converted into `"1"` in
`combined_logical`.

:::::::::::::::::::::::::

You've probably noticed that objects of different types get
converted into a single, shared type within a vector. In R, we
call converting objects from one class into another class
*coercion*. These conversions happen according to a hierarchy,
whereby some types get preferentially coerced into other
types. Can you draw a diagram that represents the hierarchy of how
these data types are coerced?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Subsetting vectors

Subsetting (extracting or indexing) involves accessing out one or more values based on their numeric placement or "index" within a vector. If we want to subset one or several values from a vector, we must provide one index or several indices in square brackets.  For instance:

> üí° **Instructor note:** Explain what each line does`.

```{r, results="show", purl=FALSE}
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type[2]
respondent_wall_type[c(3, 2)]
```

We can also repeat the indices to create an object with more elements than the
original one:

```{r, results="show", purl=FALSE}
more_respondent_wall_type <- respondent_wall_type[c(1, 2, 3, 2, 1, 3)]
more_respondent_wall_type
```

R indices start at 1. (MATLAB, Julia, and R) like human
C family (including C++, Java, Perl, and Python) count from 0 because that's
simpler for computers to do.

### Conditional subsetting

Another common way of subsetting is by using a logical vector. `TRUE` will
select the element with the same index, while `FALSE` will not:

```{r, results="show", purl=FALSE}
hh_members <- c(3, 7, 10, 6)
hh_members[c(TRUE, FALSE, TRUE, TRUE)]
```

These logical vectors not typed by hand, but are the output of
other functions or logical tests. For instance, if you wanted to select only the
values above 5:

> üí° **Instructor note:** Explain what each line does`.

```{r, results="show", purl=FALSE}
hh_members > 5    # will return logicals with TRUE for the indices that meet the condition
## so we can use this to select only the values above 5
hh_members[hh_members > 5]

which(hh_members > 5) # index of those filling the conditions 
hh_members[which(hh_members > 5)]

```

Combine multiple tests using `&` or `|`

```{r, results="show", purl=FALSE}
hh_members[hh_members < 4 | hh_members > 7]
hh_members[hh_members >= 4 & hh_members <= 7]
```

`==` "equal to". (test numerical equality)
`=` sign, which performs variable assignment. 

- Common task is to search for certain strings in a vector.
Could use `|` to test for equality to multiple values, but this can quickly
become tedious.

```{r, results="show", purl=FALSE}
possessions <- c("car", "bicycle", "radio", "television", "mobile_phone")
possessions[possessions == "car" | possessions == "bicycle"] # returns both car and bicycle
```

The function `%in%` allows you to test if any of the elements of a search vector
(on the left hand side) are found in the target vector (on the right hand side):

```{r, results="show", purl=FALSE}
possessions %in% c("car", "bicycle")
```

Same size because check all of them.

```{r, results="show", purl=FALSE}
possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")
possessions[possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")]
```

> üí° **Instructor note:** Explain how this relates to their data.

## Missing data

R was designed to analyze datasets, -> concept of missing data, represented as `NA`.

When doing operations on numbers, most functions will return `NA` if the data
you are working with include missing values. More difficult to 
ignore cases where you are dealing with missing data.
- `na.rm=TRUE`

```{r, purl=FALSE}
rooms <- c(2, 1, 1, NA, 7)
mean(rooms)
max(rooms)
mean(rooms, na.rm = TRUE)
max(rooms, na.rm = TRUE)
```

> üí° **Instructor note:** Explain what each line does`.

If your data include missing values, you may want to become familiar with the
functions `is.na()`, `na.omit()`, and `complete.cases()`. See below for
examples.

```{r, purl=FALSE}
## Extract those elements which are not missing values.
## The ! character is also called the NOT operator
rooms[!is.na(rooms)]

## Count the number of missing values.
## The output of is.na() is a logical vector (TRUE/FALSE equivalent to 1/0) so the sum() function here is effectively counting
sum(is.na(rooms))

## Returns the object with incomplete cases removed. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
na.omit(rooms)

## Extract those elements which are complete cases. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
rooms[complete.cases(rooms)]
```
:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

1. Using this vector of rooms, create a new vector with the NAs removed.

```r
rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
```

2. Use the function `median()` to calculate the median of the `rooms` vector.

3. Use R to figure out how many households in the set use more than 2 rooms for sleeping.

:::::::::::::::  solution

## Solution

```{r, answer=TRUE}
rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
rooms_no_na <- rooms[!is.na(rooms)]
# or
rooms_no_na <- na.omit(rooms)
# 2.
median(rooms, na.rm = TRUE)
# 3.
rooms_above_2 <- rooms_no_na[rooms_no_na > 2]
length(rooms_above_2)
# or
sum(rooms_no_na > 2)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Now that we have learned how to write scripts, and the basics of R's data
structures, we are ready to start working with the SAFI dataset and learn about data frames.

## Getting help

`?`
`help()`

* Search the internet
* Stack Overflow can be particularly helpful for this: answers to questions are presented as a ranked thread ordered according to how useful other users found them to be. You can search using the `[r]` tag. 
* **Take care**: copying and pasting code written by somebody else is risky unless you understand exactly what it is doing!
* Ask somebody ‚Äúin the real world‚Äù. Also during that workshop.

### Generative AI

It is increasingly common for people to use _generative AI_ chatbots such as ChatGPT to get help while coding.
Useful guidance. 
Different from human. 
Direct response VS _most likely_ sequence of text that would follow the prompt they are given.
Not always reliable despit helpful. 
Often trained on data without people consent. On very large volumes of data, much of it taken from the internet, and the responses they produce reflect that training data, and may recapitulate its inaccuracies or biases.

Concerns also exist about the way the data for this training was obtained, with questions raised about whether the people developing the LLMs had permission to use it.
Other ethical concerns have also been raised, such as reports that workers were exploited during the training process.

**We recommend that you avoid getting help from generative AI during the workshop** for several reasons:

1. For most problems you will encounter at this stage, help and answers can be found among the first results returned by searching the internet.
2. The foundational knowledge and skills you will learn in this lesson by writing and fixing your own programs  are essential to be able to evaluate the correctness and safety of any code you receive from online help or a generative AI chatbot. 
   If you choose to use these tools in the future, the expertise you gain from learning and practicing these fundamentals on your own will help you use them more effectively.


