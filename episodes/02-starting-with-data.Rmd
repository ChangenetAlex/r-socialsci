---
title: Starting with Data
teaching: 50
exercises: 30
source: Rmd
---

```{r setup, include=FALSE}
source("data/download_data.R")
```

:::: instructor

Main goals: 

- Working with data frames, and bracket notation to select slices/columns.
- To expose learners to factors. Behavior is not intuitive.

::::::::::::

::::::::::::::::::::::::::::::::::::::: objectives

- Describe what a data frame is.
- Load external data from a .csv file into a data frame.
- Summarize the contents of a data frame.
- Subset values from data frames.
- Describe the difference between a factor and a string.
- Convert between strings and factors.
- Reorder and rename factors.
- Change how character strings are handled in a data frame.
- Examine and change date formats.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- What is a data.frame?
- How can I read a complete csv file into R?
- How can I get basic summary information about my dataset?
- How can I change the way R treats strings in my dataset?
- Why would I want strings to be treated differently?
- How are dates represented in R and how can I change the format?

::::::::::::::::::::::::::::::::::::::::::::::::::

## What are data frames?

- *de facto* data structure for tabular data in `R`: data processing, statistics, and plotting.
- data in the format of a **table** where the **columns are vectors the same length**
- Similar to spreadsheet but column must contain a single type of data. 

> ðŸ’¡ **Instructor note:** Draw or show on the course material the figure`.


- Can be created by hand but usually: `read_csv()` or `read_table()`
- What these does and that's what will'do now. 


## Presentation of the SAFI Data

- SAFI (Studying African Farmer-Led Irrigation) is a study looking at farming
and irrigation methods in Tanzania and Mozambique. The survey data
was collected through interviews conducted between November 2016 and
June 2017. For this lesson, we will be using a subset of the
available data.
- Subset cleaned version of the dataset (`data/SAFI_clean.csv`).
- Missing data is encoded as "NULL", 
- row = a single interview respondent, 
- columns

> ðŸ’¡ **Instructor note:** Don't go though it all. Open with excel and inspect`.


| column\_name          | description                                                                                                                      | 
| -------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| key\_id               | Added to provide a unique Id for each observation. (The InstanceID field does this as well but it is not as convenient to use)   | 
| village              | Village name                                                                                                                     | 
| interview\_date       | Date of interview                                                                                                                | 
| no\_membrs            | How many members in the household?                                                                                               | 
| years\_liv            | How many years have you been living in this village or neighboring village?                                                      | 
| respondent\_wall\_type | What type of walls does their house have (from list)                                                                             | 
| rooms                | How many rooms in the main house are used for sleeping?                                                                          | 
| memb\_assoc           | Are you a member of an irrigation association?                                                                                   | 
| affect\_conflicts     | Have you been affected by conflicts with other irrigators in the area?                                                           | 
| liv\_count            | Number of livestock owned.                                                                                                       | 
| items\_owned          | Which of the following items are owned by the household? (list)                                                                  | 
| no\_meals             | How many meals do people in your household normally eat in a day?                                                                | 
| months\_lack\_food     | Indicate which months, In the last 12 months have you faced a situation when you did not have enough food to feed the household? | 
| instanceID           | Unique identifier for the form data submission                                                                                   | 

## Importing data

- We will be using the function `read_csv()` from the **`readr`** package part of `tidyverse`
- Needs loading

> ðŸ’¡ **Instructor note:** Talk about conflict`.

Names of function already in pre-loaded package. Introduce conflict.
Default: most recently loaded package.

Useful:

- `conflicted::conflict_scout()`: Shows us any conflicted functions.  
- `conflict_prefer("function", "package_prefered")`:  Allows us to choose the
default function we want from now on.  
- Call from package: `stats::filter()`.

### Here package 

* Difficult to specify paths to file locations. 
* **here** package! Create relative paths to the top-level directory (your RStudio project). *regardless* of where the associated source file lives even in different subdirectories. 

> ðŸ’¡ **Instructor note:** Example if we are located in "script" folder. We can still call 'data' folder`.

- Specify `na = NULL`

```{r, eval=FALSE, message=FALSE, purl=FALSE}
library(tidyverse)
library(here)

interviews <- read_csv(
  here("data","SAFI_clean.csv"), 
  na = "NULL")
```

> ðŸ’¡ **Instructor note:** Import using click as an alternative?
> ðŸ’¡ **Instructor note:** Explain arguments in herer

- Folder and file arg with quotes. 
- As many as necessary (example: `here("analysis", "data", "surveys", "clean", "SAFI_clean.csv)`)
- Also accept: / `here("data/SAFI_clean.csv")` 

- Notice autocompletion `read_csv()` and base `read.csv()`. 
- Similar but coercion in base (`interview date` becomes `interview.date`). 
- `data.frame` vs `tibble`.
- Assignment so nothing is printed
- To see the data, options are: 

```{r, results="hold", purl=FALSE}
interviews
## Try also
view(interviews)
head(interviews)
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Note

- `read_csv()` assumes fields are delimited by commas
- If semicolon used instead: `read_csv2` function. 
- Check helps of both `?read_csv` 

::::::::::::::::::::::::::::::::::::::::::::::::::

- `read_csv()` class vs base function

```{r, results="hold", purl=FALSE}
class(interviews)

# Only class data frame if using read.csv
interviews_df_only <- read.csv(
  here("data","SAFI_clean.csv"), 
  na = "NULL")
class(interviews_df_only)
```

## Inspecting data frames

> ðŸ’¡ **Instructor note:** Show how to inspect from environement and what is display when printing in console and what info is shown

* There are functions to extract specific info 

Size:

- `dim(interviews)` - For dimensions (vector)
- `nrow(interviews)` - returns the number of rows
- `ncol(interviews)` - returns the number of columns

Content:

- `head(interviews)` - shows the first 6 rows
- `tail(interviews)` - shows the last 6 rows

Names:

- `names(interviews)` - returns the column names (synonym of `colnames()` for
  `data.frame` objects)

Summary:

- `str(interviews)` - structure of the object and information about the class,
  length and content of each column
- `summary(interviews)` - summary statistics for each column
- `glimpse(interviews)` - fit the screen + non base

Note: most of these functions are "generic." They can be used on other types of
objects besides data frames or tibbles.

## Subsetting data frames

- Our `interviews` data frame has rows and columns (it has 2 dimensions).
- We might want part of the data
- Need to specify coordinates. Row then col

```{r, purl=FALSE}
## first element in the first column of the tibble
interviews[1, 1]
## first element in the 6th column of the tibble 
interviews[1, 6]
## first column of the tibble (as a vector)
interviews[[1]]
## first column of the tibble
interviews[1]

## first three elements in the 7th column of the tibble
interviews[1:3, 7]

## the 3rd row of the tibble
interviews[3, ]

interviews[, 1]

## equivalent to head_interviews <- head(interviews)
head_interviews <- interviews[1:6, ]
```

- `:` special function tcreating numleric vectors `1:10` and `10:1`.
- Exclude indices using "`-`"

```{r, purl=FALSE, eval=FALSE}
interviews[, -1]          # The whole tibble, except the first column
interviews[-c(7:131), ]   # Equivalent to head(interviews)
```

`tibble`s can be subset by calling indices (as shown previously), but also by
calling their column names directly:

```{r, eval=FALSE, purl=FALSE}
interviews["village"]       # Result is a tibble
interviews[, "village"]     # Result is a tibble
interviews[["village"]]     # Result is a vector
interviews$village          # Result is a vector
# Several 
interviews[, c("village", "xxx")]     # Result is a tibble
# Mix 
interviews[1:10, c("village", "xxx")]     # Result is a tibble
# Conditions 
interviews[, "no_membrs">7]     # Result is a tibble



```

- Autocompletion

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

1. Create a tibble (`interviews_100`) containing only the data in
  row 100 of the `interviews` dataset.

Now, continue using `interviews` for each of the following activities: 

2. Notice how `nrow()` gave you the number of rows in the tibble?

- Use that number to pull out just that last row in the tibble.
- Compare that with what you see as the last row using `tail()` to make
  sure it's meeting expectations.
- Pull out that last row using `nrow()` instead of the row number.
- Create a new tibble (`interviews_last`) from that last row.

3. Using the number of rows in the interviews dataset that you found in
  question 2, extract the row that is in the middle of the dataset. Store
  the content of this middle row in an object named `interviews_middle`.
  (hint: This dataset has an odd number of rows, so finding the middle is a
  bit trickier than dividing n\_rows by 2. Use the median( ) function and what
  you've learned about sequences in R to extract the middle row!

4. Combine `nrow()` with the `-` notation above to reproduce the behavior of
  `head(interviews)`, keeping just the first through 6th rows of the
  interviews dataset.

5. Can you use the dim() function to to pull out the last row in the tibble? Write your answer below.

6. Can you select those rows of the data frame with a years_liv values above 40? How many are there?

:::::::::::::::  solution

## Solution

```{r}
## 1.
interviews_100 <- interviews[100, ]
## 2.
# Saving `n_rows` to improve readability and reduce duplication
n_rows <- nrow(interviews)
interviews_last <- interviews[n_rows, ]
## 3.
interviews_middle <- interviews[median(1:n_rows), ]
## 4.
interviews_head <- interviews[-(7:n_rows), ]

# 5
interviews[dim(interviews)[1],]

#6
nrow(interviews[interviews$years_liv > 40, ])
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Factors

- Special data class to deal with categorical data. 
- They are stored as integers associated with labels and they can be ordered (ordinal) or unordered (nominal).
- Factors create a structured relation between the different levels (values)
- Look like character but treated as integer vectors.

- Factors can only contain a pre-defined set of values = *levels*. 
- By default alphabetical order.

```{r, purl=TRUE}
respondent_floor_type <- factor(c("earth", "cement", "cement", "earth"))
```

- R assign `1` to `"cement"` and `2` to `"earth"`
- Check this functions to find out 

```{r, purl=FALSE}
levels(respondent_floor_type)
nlevels(respondent_floor_type)
```

- Sometimes order does not matter
- Other times meaningful (e.g., "low", "medium", "high"). Viz example. 

- See for reordering
```{r, results=TRUE, purl=FALSE}
respondent_floor_type # current order
respondent_floor_type <- factor(respondent_floor_type, 
                                levels = c("earth", "cement"))
respondent_floor_type # after re-ordering
```

- In R they are integers (1, 2), but are more informative than integers because self describing: `"cement"`,
`"earth"` is more descriptive than `1`, and `2`. 
- Which one is "earth"?
- Useful when lots
- Renaming easier: example "cement" to "brick". 
- `fct_recode()` from **`forcats`**

```{r, results=TRUE, purl=FALSE}
levels(respondent_floor_type)
respondent_floor_type <- fct_recode(respondent_floor_type, brick = "cement")

## as an alternative, we could change the "cement" level directly using the
## levels() function, but we have to remember that "cement" is the second level
levels(respondent_floor_type)
levels(respondent_floor_type)[2] <- "brick"
levels(respondent_floor_type)
respondent_floor_type
```

- Unordered for now (nominal).
- `ordered=TRUE`

```{r, results=TRUE, purl=FALSE}
respondent_floor_type_ordered <- factor(respondent_floor_type, 
                                        ordered = TRUE)
respondent_floor_type_ordered # after setting as ordered factor
```

### Converting factors

- Convert a factor to a character vector `as.character(x)`.

```{r, purl=FALSE}
as.character(respondent_floor_type)
```

- Converting factors when levels are numbers is trickier. 
- `as.numeric()` returns the index values of the factor, not its levels
- Two methods: 

```{r, purl=TRUE}
year_fct <- factor(c(1990, 1983, 1977, 1998, 1990))
as.numeric(year_fct)                     # Wrong! And there is no warning...
as.numeric(as.character(year_fct))       # Works...
as.numeric(levels(year_fct))[year_fct]   # The recommended way.
```

Notice that in the recommended `levels()` approach, three important steps occur:

- We obtain all the factor levels using `levels(year_fct)`
- We convert these levels to numeric values using `as.numeric(levels(year_fct))`
- We then access these numeric values using the underlying integers of the
  vector `year_fct` inside the square brackets

### Renaming factors

- When factor, can `plot()` for a barplot distrib.
- `memb_assoc`: 

```{r factor-plot-default-order, eval=F, purl=TRUE}
## create a vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

## convert it into a factor
memb_assoc <- as.factor(memb_assoc)

## let's see what it looks like
memb_assoc

## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
```

- We see NA non rezspoindent dont appear in the plot by default.
- We can recode them to for them to appear following same steps.

```{r factor-plot-reorder, eval=FALSE, purl=TRUE}
## Let's recreate the vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc
## replace the missing data with "undetermined"
memb_assoc[is.na(memb_assoc)] <- "undetermined"
## convert it into a factor
memb_assoc <- as.factor(memb_assoc)
## let's see what it looks like
memb_assoc
## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

- Rename the levels of the factor to have the first letter in uppercase:
  "No","Undetermined", and "Yes".

- Now that we have renamed the factor level to "Undetermined", can you
  recreate the barplot such that "Undetermined" is last (after "Yes")?

:::::::::::::::  solution

## Solution

```{r factor-plot-exercise, eval=FALSE}
## Rename levels.
memb_assoc <- fct_recode(memb_assoc, No = "no",
                         Undetermined = "undetermined", Yes = "yes")
## Reorder levels. Note we need to use the new level names.
memb_assoc <- factor(memb_assoc, levels = c("No", "Yes", "Undetermined"))
plot(memb_assoc)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Formatting Dates

* Wont do 
